import os.path

from gui.tailer import *

# Specialised "tailer" for dealing with ASCII time series files
# generated by GENIE.


class TimeSeriesFile:
    def __init__(self, app, p, cb):
        self.app = app  # Tkinter application.
        self.time = []  # Vector of time values.
        self.data = {}  # Dictionary of vectors of data
        # values, keyed by variable name.
        self.vars = ()  # Variable names.
        self.cb = cb  # New data callback.
        self.tailer = None
        if os.path.exists(p):
            # Set up and start tailer.
            self.time = []
            self.data = {}
            self.vars = ()
            self.tailer = Tailer(app, p)
            self.tailer.start(self.add_output)

    def stop(self):
        if self.tailer:
            self.tailer.stop()
        self.tailer = None

    def add_output(self, t):
        # Tailer callback.
        tnew = []
        dnew = []
        for l in t.splitlines():
            if self.vars == ():
                # If this is the first line in the file, it's the
                # header and we use it to determine the names of the
                # variables in the file.
                header = l.strip().lstrip("%").strip()
                header = map(lambda s: s.strip(), header.split(" / "))
                self.vars = tuple(header[1:])

                # Initialise empty data vectors for each variable.
                for v in self.vars:
                    self.data[v] = []
            else:
                # Process space-seperated data values -- the first is
                # the time, the rest are recorded in the appropriate
                # data vectors.
                l = l.strip().split()
                self.time.append(l[0])
                for i in range(1, len(l)):
                    self.data[self.vars[i - 1]].append(l[i])
                tnew.append(l[0])
                dnew.append(l[1:])

        # Call the callback with the new data -- the callback can also
        # access the full time and data vectors directly.
        self.cb(tnew, dnew)
